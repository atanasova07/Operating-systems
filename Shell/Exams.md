* Даден е текстов файл с име philip-j-fry.txt. Напишете shell script и/или серия от
команди, които извеждат броя редове, съдържащи поне една четна цифра и несъдържащи малка
латинска буква от a до w.
Примерно съдържание на файла:   
123abv123   
123zz123   
MMU_2.4  
Примерен изход:  
Броят на търсените редовете е 2
```shell
cat philip-j-fry.txt | egrep '^[2468]*[^a-w]*$' | wc -l
```

* Напишете серия от команди, извеждащи на екрана само броя на всички обекти във
файловата система, чиито собственик е текущият потребител.
```shell
find -user $(whoami) 2>/dev/null | wc -l
```

* Напишете серия от команди, които изтриват:
а) всички файлове в текущата директория и нейните поддиректории, които са с нулева дължина.  
б) 5-е най-големи файла в home директорията на текущия потребител и нейните поддиректории.
```shell
find . -type f -size 0 -delete
find . -mindepth 1 -type f -printf "%p %s"|sort -nr -k2 | head -n5 | xargs -I {} rm {}
```

* Напишете серия от команди, които от файла /etc/passwd да вземат под-низ, състоящ
се от втора и трета цифра на факултетния номер на студентите от специалност Информатика, чиито фамилии завършват на “а”. Изведете коя комбинация от цифри се среща най-често и коя е тя.
Примерно съдържание на файла:  
s45194:x:1255:502:Elizabet Mihaylova, Inf, k3, g1:/home/Inf/s45194:/bin/bash
s45139:x:1261:502:Vasilena Peycheva:/home/Inf/s45139:/bin/bash
s81257:x:1079:503:Vasilena Nikolova, KN, 2kurs, 5gr:/home/KN/s81257:/bin/bash
s81374:x:1117:503:Ivan Kamburov, KN, 2kurs, 7gr:/home/KN/s81374:/bin/bash  
Примерен изход:  
2 51
```shell
cat /etc/passwd | grep "Inf" | cut -d',' -f1 | cut -d':' -f1,5 | grep 'a$' | cut -c3,4 | sort -n | uniq -c | sort -k1 -nr | head -n1
```

* Намерете имената на топ 5 файловете в текущата директория с най-много hardlinks
```shell
find . -maxdepth 1 -type f -printf "%f %n\n" | sort -k2 -nr | cut -d' ' -f1 | head -n5
```

* Променете правата на всички директории, намиращи се някъде във вашата home
директория, така че да станат такива, каквито биха се получили, ако ги бяхте създали с маска 0022
```shell
find . -type d -maxdepth 1 -exeec chmod 644 {}\;
```

* Напишете серия от команди, извеждащи на екрана само inode-а на най-скоро променения (по съдържание) файл, намиращ се в home директорията на потребител pesho (или нейните
под-директории), който има повече от едно име.
```shell
find /home/pesho -type f -printf "%T@ %i %n\n" 2>/dev/null | sort -k1,3 -nr | head -n1 | cut -d' ' -f2
```

* При подреждане в нарастващ ред на числовите потребителски идентификатори (UID)
на акаунтите, дефинирани в системата, 201-ят акаунт е от групата, запазена за акаунти от специалност СИ.
Изведете списък с имената (име и фамилия) и home директориите на всички акаунти от специалност СИ, подреден по факултетен номер.
За справка:  
s61988:x:1219:504:Stoian Genchev,SI,2,5:/home/SI/s61988:/bin/bash  
s81430:x:1234:503:Iordan Petkov, KN, k2, g7:/home/KN/s81430:/bin/bash  
s61807:x:1248:504:Elica Venchova:/home/SI/s61807:/bin/bash  
s62009:x:1254:504:Denitsa Dobreva, 2, 6:/home/SI/s62009:/bin/bash  
s61756:x:1258:504:Katrin Kartuleva, SI, 4, 1:/home/SI/s61756:/bin/bash  
s855287:x:1195:504:Vaska Kichukova,SI,2,5:/home/SI/s855287:/bin/bash  
Примерен изход:  
Katrin Kartuleva:/home/SI/s61756  
Elica Venchova:/home/SI/s61807  
Stoian Genchev:/home/SI/s61988  
Denitsa Dobreva:/home/SI/s62009  
Vaska Kichukova:/home/SI/s855287  
```shell
cat /etc/passwd | sort -t ':' -k3 -n | head -n 201 | cut -d':' -f4 | xargs -I {} grep -F "{}" /etc/passwd | awk -F ':' '{print $5 " " $6}' | tr ',' ' ' | tr -s ' ' | awk '{print $1 " " $2 ":" $NF}'
```

* Даден е текстовият файл planets.txt, който съдържа информация за гравитационно
закръглените обекти в дадена слънчева система. На всеки ред има информация за точно един обект в следните колони, разделени с ’;’:  
• име на обекта  
• тип на обекта (един знак)  
– Т - земен тип  
– G - газов гигант  
– I - леден гигант  
• средно разстояние на обекта до локалната звезда  
• маса на обекта (относителна величина)  
• обем на обекта (относителна величина)  
• плътност (g/cm3)  
• средна орбитална скорост (km/s)  
Първият ред във файла e header, който описва имената на колоните.
Данните за обектите не са сортирани.  
Намерете и изведете разделени с таб името и масата на обекта, който е едновременно:  
  • най-близкият до локалната звезда  
  • от същия тип като типа на най-далечният до локалната звезда обект  
  
Примерен входен файл:  
name;type;distance;mass;volume;density;speed  
earth;T;1.00000011;1;1;5.52;29.7859  
mars;T;1.52366231;0.107;0.151;3.94;24.1309  
saturn;G;9.53707032;95;763.62;0.7;9.6724  
mercury;T;0.38709893;0.055;0.056;5.43;47.8725  
venus;T;0.72333199;0.815;0.857;5.24;35.0214  
jupiter;G;5.20336301;318;1321.3;1.33;13.0697  
neptune;I;30.06896348;17;57.747;1.76;5.4778  
uranus;I;19.19126393;14.5;63.102;1.3;6.8352  
```shell
cat planets.txt | tail -n+2 | cut -d';' -f1,2,3 | sort -t';' -k3 -nr | head -n1 | cut -d';' -f2 | xargs -I {} grep -F "{}" planets.txt | sort -t';' -k3 -n | head -n1 | awk -F';' '{print $1 "\t" $4}'
```

* Вие сте асистент по ОС. На първото упражнение казвате на студентите да си напишат
данните на лист, взимате го и им правите акаунти. След упражнението обаче, забравяте да вземете
листа със себе си - сещате се половин час по-късно, когато трябва да въведете имената на студентите
в таблица, но за зла беда в стаята вече няма ни помен от листа (вероятно иззет от спешния отряд
на GDPR-полицията)
Сещате се, че в началото на упражнението UNIX-часовникът е показвал 1551168000, а в края
1551176100.
Напишете команда, която изкарва разделени с таб факултетните номера и имената на потребителите от специалност СИ, чиито home директории са променили статуса си (status change time) в
зададения времеви интервал.
Приемете, че всички потребители от СИ имат home директории под /home/SI.  
Примерен изход:  
62198 Ivaylo Georgiev    
62126 Victoria Georgieva     
62009 Denitsa Dobreva    
62208 Trayana Nedelcheva    
Няколко реда от /etc/passwd за справка:  
s62136:x:1302:503:Alexander Ignatov, SI, 2, 2:/home/KN/s62136:/bin/bash  
s62171:x:1031:504:Deivid Metanov:/home/SI/s62171:/bin/bash  
s62126:x:1016:504:Victoria Georgieva:/home/SI/s62126:/bin/bash  
s62009:x:1170:504:Denitsa Dobreva,SI,3,3:/home/SI/s62009:/bin/bash  
s62196:x:1221:504:Elena Tuparova,SI,2,1:/home/SI/s62196:/bin/bash  
```shell
find /home/students/ -maxdepth 1 -mindepth 1 -printf "%C@ %f\n" | awk '($1 <= 1551176100 && $1 >= 1551168000) {print $2}' | xargs -I {} grep "{}" /etc/passwd | grep "/home/SI" | cut -d':' -f1,5 | cut -c2- | awk -F':' '{print $1 "\t" $2}' | awk -F',' '{print $1}'
```

*  От всички файлове в home директорията на потребителя velin, изведете дълбочината
на файл, който:  
• има същия inode като този на най-скоро променения файл сред тях   
• има минимална дълбочина  
```shell
find /home/velin -printf "%T@ %f %i\n" 2>/dev/null | sort -k1 -nr | head -n1 | awk '{print $3}' | xargs -I {} find /home/velin -inum "{}" -printf "%i %d %f\n" 2>/dev/null | sort -k2 | head -n1 | cut -d ' ' -f2
```

* За всички файлове, които (едновременно):  
• се намират някъде във вашата home директория;  
• имат права, каквито биха имали, ако ги бяхте създали с маска 0022  
променете правата им така, че group owner-а на файла да има право да пише в него.
```shell
find . -type f -perm 644 | xargs -I {} chmod g+w "{}"
```

* Даден е текстовият файл spacex.txt, който съдържа информация за полети на
ракети на SpaceX. На всеки ред има информация за един такъв полет в следните колони, разделени
с вертикална черта ’|’:  
• дата на полета в UNIX формат  
• космодрум  
• успешност на полета (две възможни стойности)  
– Success - успешен полет  
– Failure - неуспешен полет  
• полезен товар  
Първият ред във файла e header, който описва имената на колоните. Данните във файла не са
сортирани.  
Намерете и изведете разделени с двоеточие (’:’) успешността и информацията за полезния товар
на най-скорощния полет, който е изстрелян от космодрума с най-много неуспешни полети.  
Примерен входен файл:  
date|launch site|outcome|payload  
1291759200|CCAFS|Success|Dragon demo flight and cheese   
1435438800|CCAFS|Failure|SpaceX CRS-7   
1275666300|CCAFS|Success|Dragon Spacecraft Qualification Unit   
1452981600|VAFB|Success|Jason-3   
1498165200|KSC|Success|BulgariaSat-1   
1473454800|CCAFS|Failure|Amos-6   
1517868000|KSC|Success|Elon Musk’s Tesla   
1405285200|CCAFS|Success|Orbcomm  
```shell
cat spaces.txt | grep $(cat spaces.txt | tail -n+2 | grep 'Failure' | cut -d'|' -f2 | sort -d | uniq -c | sort -k1 -nr | head -n1 | awk '{print $2}') | sort -t'|' -k1 -nr | head -n1 | awk -F'|' '{print $3 ":" $4}'
```

* Напишете серия от команди, които намират всички обикновени файлове, отговарящи едновременно
на следните условия:  
• намират се в home директорията на текущия потребител, но не и в нейните под-директории;  
• собственик им е текущият потребител.  
Серията от команди трябва да променя правата на намерените файлове така, че да станат такива,
каквито биха се получили, ако при създаването на файловете ефективната маска е била 0002.
Гарантирайте, че серията от команди няма изход.
```shell
find . -type f -maxdepth 1 -user $(whoami) | xargs -I {} chmod 664 "{}" >/dev/null
```

 * Напишете shell скрипт, който по подаден един позиционен параметър, ако този
параметър е директория, намира всички symlink-ове в нея и под-директориите `и с несъществуващ
destination.
```shell
#!/bin/bash

if [[ ${#} -ne 1 ]]; then
        echo "Invalid number of arguments!"
        exit 1
fi

if [[ ! -d $1 ]]; then
        echo "Not a directory"
        exit 1
fi

find $1 -type l -exec [ ! -e {} ] \; -printf "%p\n"
```

* В текущата директория има само обикновени файлове (без директории). Да се
напише bash script, който приема 2 позиционни параметъра – числа, който мести файловете от
текущата директория към нови директории (a, b и c, които трябва да бъдат създадени), като
определен файл се мести към директория ’a’, само ако той има по-малко редове от първи позиционен
параметър, мести към директория ’b’, ако редове са между първи и втори позиционен параметър
и в ’c’ в останалите случаи.
```shell
#!/bin/bash

if [[ $# -ne 2 ]]; then
        echo "Invalid number of arguments!"
        exit 1
fi

if [[ ! $1=~"^[0-9]+$" || ! $2=~"^[0-9]+$" ]]; then
        echo "The arguments must be numbers!"
        exit 1
fi

mkdir "a"
mkdir "b"
mkdir "c"

for file in $(find . -type f); do
        lines=$(cat $file | wc -l)
        if [[ $lines -lt $1 ]]; then
                mv $file "a"
        elif [[ $lines -gt $1 && $lines -lt $2 ]]; then
                mv $file "b"
        elif
                mv $file "c"
        fi
done
```

* Файловете във вашата home директория съдържат информация за музикални албуми и имат специфична структура. Началото на всеки ред е годината на издаване на албума, а
непосредствено, след началото на всеки ред следва името на изпълителя на песента. Имената на
файловете се състоят от една дума, която съвпада с името на изпълнителя.  
Примерно съдържание на файл с име "Bonnie":   
2005г. Bonnie - "God Was in the Water" (Randall Bramblett, Davis Causey) – 5:17   
2005г. Bonnie - "Love on One Condition" (Jon Cleary) – 3:43   
2005г. Bonnie - "So Close" (Tony Arata, George Marinelli, Pete Wasner) – 3:22   
2005г. Bonnie - "Trinkets" (Emory Joseph) – 5:02   
2005г. Bonnie - "Crooked Crown" (David Batteau, Maia Sharp) – 3:49   
2005г. Bonnie - "Unnecessarily Mercenary" (Jon Cleary) – 3:51   
2005г. Bonnie - "I Will Not Be Broken" - "Deep Water" (John Capek, Marc Jordan) – 3:58   
Да се напише shell скрипт приемащ два параметъра, които са имена на файлове от вашата home директория. Скриптът сравнява, кой от двата файла има повече на брой редове, съдържащи неговото
име (на файла). За файлът победител изпълнете следните действия:
• извлечете съдържанието му, без годината на издаване на албума и без името на изпълнителя
• сортирайте лексикографски извлеченото съдържание и го запишете във файл с име ’изпълнител.songs’   
Примерен изходен файл (с име Bonnie.songs):   
"Crooked Crown" (David Batteau, Maia Sharp) – 3:49    
"God Was in the Water" (Randall Bramblett, Davis Causey) – 5:17          
"I Will Not Be Broken" - "Deep Water" (John Capek, Marc Jordan) – 3:58      
"Love on One Condition" (Jon Cleary) – 3:43        
"So Close" (Tony Arata, George Marinelli, Pete Wasner) – 3:22       
"Trinkets" (Emory Joseph) – 5:02       
"Unnecessarily Mercenary" (Jon Cleary) – 3:51

```shell
#!/bin/bash

if [[ $# -ne 2 ]]; then
        echo "Invalid number of arguments"
        exit 1
fi

if [[ -z $1 || -z $2 ]]; then
        echo "Arguments must be string"
        exit 1
fi

if [[ ! -f $1 || ! -f $2 ]]; then
        echo "Files don't exist"
        exit 1
fi

linesFile1=$(cat $1 | grep $1 | wc -l)
linesFile2=$(cat $2 | grep $2 | wc -l)

if [[ $linesFile1 > $linesFile2 ]]; then
        cat $1 | cut -d'-' -f 2,3 | sort -t'-' -k 1 -d > "$1.songs"
else
        cat $2 | cut -d'-' -f 2,3 | sort -t'-' -k 1 -d > "$2.songs"
fi
```

* Имате текстов файл със следното съдържание (всяка книга е на един ред):   
1979 г. - „Синият тайфун“ (сборник съветски научнофантастични разкази за морето)    
1979 г. - „Двойната звезда“ - Любен Дилов    
1979 г. - „Завръщане от звездите“ - Станислав Лем (Превод: Веселин Маринов)   
1979 г. - „Среща с Рама“ - Артър Кларк (Превод: Александър Бояджиев)   
1979 г. - „Алиби“ - Димитър Пеев (криминален роман)    
1979 г. - „Тайнственият триъгълник“ (сборник НФ разкази за морето)    
1979 г. - „Второто нашествие на марсианците“ - Аркадий и Борис Стругацки    
1979 г. - „Гробищен свят“ - Клифърд Саймък (Превод: Михаил Грънчаров)    
1979 г. - „Чоки“ - Джон Уиндъм (Превод: Теодора Давидова)    
1979 г. - „Спускане в Маелстрьом“ - Едгар Алан По (Превод: Александър Бояджиев)    
1980 г. - „Допълнителна примамка“ - Робърт Ф. Йънг (Превод: Искра Иванова, ...)    
1980 г. - „Кристалното яйце“ - Хърбърт Уелс (Превод: Борис Миндов, ...)     
1980 г. - „Онирофилм“ (сборник италиански НФ разкази) (Превод: Никола Иванов, ...)   
Напишете shell script (приемащ аргумент име на файл) който извежда:   
• всеки ред от файла с добавен пореден номер във формат "1. ", "2. ", ... "11. " ...  
• махат данните за годината на издаване    
• сортират изхода по заглавие (лексикографски, възходящо)   
Примерен изход (показани са само първите 4 реда):   
5. „Алиби“ - Димитър Пеев (криминален роман)   
7. „Второто нашествие на марсианците“ - Аркадий и Борис Стругацки   
8. „Гробищен свят“ - Клифърд Саймък (Превод: Михаил Грънчаров)    
2. „Двойната звезда“ - Любен Дилов   

```shell
#!/bin/bash

if [[ $# -ne 1 ]]; then
        echo "Invalid number of arguments"
        exit 1
fi

if [[ -z $1 ]]; then
        echo "Argument must be a string"
        exit 1
fi

if [[ ! -f $1 ]]; then
        echo "File doesn't exist"
        exit 1
fi

cat $1 | cut -d '-' -f 2- | sed 's/^ //' | awk '{print NR ". " $0}' | sed 's/„/@/' | sed 's/“/@/' | sort -t '@' -k2 | sed 's/@/„/1' | sed 's/@/“/1'
```

* Напишете скрипт, който приема три задължителни позицонни аргумента:   
• име на файл   
• низ1   
• низ2   
Файлът е текстови, и съдържа редове във формат:
ключ=стойност, където стойност може да бъде:  
• празен низ, т.е. редът е ключ=  
• низ, състоящ се от един или повече термове, разделени с интервали, т.е., редът е ключ=t1 t2
t3   
Някъде във файла:   
• се съдържа един ред с ключ първия подаден низ (низ1 );   
• и може да се съдържа един ред с ключ втория подаден низ (низ2 ).   
Скриптът трябва да променя реда с ключ низ2 така, че обединението на термовете на редовете с
ключове низ1 и низ2 да включва всеки терм еднократно.  
Примерен входен файл:   
$ cat z1.txt   
FOO=73    
BAR=42    
BAZ=     
ENABLED_OPTIONS=a b c d       
ENABLED_OPTIONS_EXTRA=c e f      
Примерно извикване:     
$ ./a.sh z1.txt ENABLED_OPTIONS ENABLED_OPTIONS_EXTRA     
Изходен файл:    
$ cat z1.txt      
FOO=73      
BAR=42      
BAZ=       
ENABLED_OPTIONS=a b c d     
ENABLED_OPTIONS_EXTRA=e f     

```shell
#!/bin/bash

if [[ $# -ne 3 ]]; then
        echo "Invalid number of arguments"
        exit 1
fi

if [[ ! -f $1 ]]; then
        echo "The first argument must be a file"
        exit 1
fi

string1=$(cat $1 | grep "$2=" | cut -d'=' -f2 | tr ' ' '\n')
string2=$(cat $1 | grep "$3=" | cut -d'=' -f2 | tr ' ' '\n')
line=""

for el in $string2; do
        for ch in $string1; do
                if [ $el == $ch ]; then
                        flag=1
                        break
                fi
        done
        if [[ $flag -ne 1 ]]; then
                line+="$el "
        else
                flag=""
        fi
done

toReplace=$(cat $1 | grep "$3=.*")
sed -i -E "s/$toReplace/$3=$line/g" $1
```

* Напишете скрипт, който извежда името на потребителския акаунт, в чиято home
директория има най-скоро променен обикновен файл и кой е този файл. Напишете скрипта с подходящите проверки, така че да бъде валиден инструмент.
```shell
#!/bin/bash

if [[ $# -ne 0 ]]; then
        echo "Invalid number of arguments"
        exit 1
fi

cat /etc/passwd | cut -d':' -f6 | grep "home" | xargs -I {} find "{}" -type f -printf "%TT %f %u\n" 2>/dev/null | sort -k1 -nr | head -n1 | cut -d' ' -f2,3
```

* Напишете скрипт, който получава задължителен първи позиционен параметър – директория и незадължителен втори – число. Скриптът трябва да проверява подадената директория
и нейните под-директории и да извежда имената на:  
а) при подаден на скрипта втори параметър – всички файлове с брой hardlink-ове поне равен на
параметъра;  
б) при липса на втори параметър – всички symlink-ове с несъществуващ destination (счупени
symlink-ове).  
Забележка:За удобство приемаме, че ако има подаден втори параметър, то той е число
```shell
if [[ ! -d $1 ]]; then
        echo "The first argument must be a directory"
        exit 1
fi

if [[ $# -gt 2 ]]; then
        echo "Invalid number of arguments"
        exit 1
fi

if [[ $# -eq 2 ]]; then
        find $1 -type f -printf "%n %f\n" 2>/dev/null | awk -v param=$2 '$1 >= param {print $2}'
elif [[ $# -eq 1 ]]; then
        find $1 -type l 2>/dev/null -exec [ ! -e {} ] \; -printf "%f\n"
fi
```

